# mixins
пример некоторых полезных миксинов
#Вложенные правила:
вы можете вкладывать CSS свойства, в несколько наборов скобок {}. Это сделает ваш CSS чище и понятней.

# Переменные: 
в стандартном CSS тоже есть переменные, но переменные Sass куда более мощный инструмент. 
Например, вы можете использовать переменные в циклах и генерировать значения свойств динамически. 
Также можно внедрять переменные в имена свойств, например так: property-name-N { … }.

# Лучшая реализация операторов: 
вы можете суммировать, вычитать, делить и умножать CSS значения. Sass реализация более интуитивна, чем стандартный функционал CSS calc().
Функции: Sass позволяет многократно использовать CSS стили, как функции.

# Тригонометрия: 
помимо базовых операций (+, -, *, /), SCSS позволяет писать собственные функции. Например, функции sin и cos можно написать, 
используя только синтаксис Sass/SCSS. 
Конечно, вам понадобятся знания тригонометрии. Такие функция могут понадобится для создания анимации.
Удобный рабочий процесс: вы можете писать CSS, используя конструкции, знакомые по другим языкам: for-циклы, while-циклы, if-else. 
Но имейте в виду, это только препроцессор, а не полноценный язык, Sass контролирует генерацию свойств и значений, а на выходе вы получаете стандартный CSS.
Миксины: позволяют один раз создать набор правил, чтобы потом использовать их многократно или смешивать с другими правилами. 
Например, миксины используют для создания отдельных тем макета.

# Переменные
В Sass/SCSS есть переменные, и они отличаются от тех, которые вы вероятно видели в CSS — они начинаются с двух тире (--color: #9c27b0). 
В SCSS переменная обозначается знаком доллара ($color: #9c27b0).
Вы можете перезаписать имя переменной или задать для неё значение по умолчанию.
Для этого добавьте метку !default к переменной, и если её значение не изменится в дальнейшем и не будет пустым, то будет использоваться заданное значение по умолчанию.
```
$number: 1;
$color: #ff0000;
$text: "tproger forever.";
$text: "IT forever." !default;
$nothing: null;
```
Вы можете перезаписать имя переменной или задать для неё значение по умолчанию. Для этого добавьте метку !default к переменной,
и если её значение не изменится в дальнейшем и не будет пустым, то будет использоваться заданное значение по умолчанию.

#Вложенные правила:
Стандартные вложенные CSS-элементы с использованием пробела:
/* Вложенные правила */
```
#A {
  color: red;
  #B {
    color: green;
    #C p {
      color: blue;
    }
  }
}
```
# Амперсанд
В SCSS используется директива &.
```
#p {
  color: black;
  a {
    font-weight: bold;
    &:hover {
      color: red;
    }
  }
}
```
С помощью символа & вы можете явно указать, где должен быть вставлен родительский селектор.
Миксины (они же примеси)
Миксины объявляются директивой @mixin. После неё должно стоять имя миксина и, опционально, его параметры, а также блок, содержащий тело миксина. 
Например, можно определить миксин flexible(), который далее будет включён, например, в класс .centered-elements следующим образом:
```
@mixin flexible () {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  ```
  ```
.centered-elements {
    @include flexible ();
    border: 1px solid gray;
  }
  ```
  Теперь каждый раз после применения класса .centered-elements к HTML-элементу, последний будет преобразован во Flexbox.

# Миксины:
могут также содержать селекторы, в том числе со свойствами. А селекторы могут содержать ссылки на родительский элемент через амперсанд (&), вы ведь помните про него?
Пример работы с несколькими браузерами
Некоторые вещи в CSS весьма утомительно писать, особенно в CSS3, где плюс ко всему зачастую требуется использовать большое количество вендорных префиксов( -webkit- или -moz-).

Миксины позволяют создавать группы деклараций CSS, которые вам придётся использовать несколько раз на сайте. 
Хорошей практикой будет использование миксинов для вендорных префиксов. 

##Пример:
```
@mixin border-radius($radius) {        // Префиксы для:
    -webkit-border-radius: $radius;    // Chrome и Safari
       -moz-border-radius: $radius;    // Firefox
        -ms-border-radius: $radius;    // Internet Explorer
         -o-border-radius: $radius;    // Opera
            border-radius: $radius;    // Стандартный CSS
  }
  ```
// Пример использования миксина border-radius после его создания
.box { @include border-radius(10px); }

# Арифметические операции
Как и в реальной жизни, вы не можете работать с числами, у которых несовместимы типы данных (например, сложение рх и em).

# Сложение и вычитание
p {
    font-size: 10px + 2em;  // ОШИБКА!
    font-size: 10px + 6px;  // 16px
    font-size: 10px + 2;    // 12px
}
Всегда обращайте внимание на тип складываемых данных. То есть пиксели к пикселям, слоны к слонам. Таким же образом работает вычитание, но со знаком минус.

# Пример вычитания:
div {
    height: 12% - 2%;
    margin: 4rem - 1;
}
Умножение
Выполняется точно так же, как в CSS, с помощью calc(a * b), но без calc и круглых скобок. Кроме того, можно ещё отделять знак умножения пробелами от чисел (5*6 == 5 * 6).

Исключение Нельзя умножать пиксели между собой. То есть, 10px * 10px != 100px. 10px * 10 == 100px.
# ПримерУмножения:
p {
    width: 10px * 10px;           // ОШИБКА!
    width: 10px * 10;             // 100px
    width: 1px * 5 + 5px;         // 10px
    width: 5 * (5px + 5px);       // 50px
    width: 5px + (10px / 2) * 3;  // 20px
}
# Деление
С делением дела обстоят немного сложнее, но разобраться можно, ведь в стандартном CSS косая линия (слэш) зарезервирована для использования краткой формы записи свойств. 




/* стандартная форма записи свойств */
font-style: italic;
font-weight: bold;
font-size: .8em;
line-height: 1.2;
font-family: Arial, sans-serif;
Есть три помощника, которые намекнут на возможность деления:
Значение (или любая его часть) хранится в переменной или возвращается функцией.
Значения заключены в круглые скобки.
Значение используется как часть другого арифметического выражения.
Пример:
$var1: 20;
$var2: 4;

p {
    top: 16px / 24px;          // Отображается без изменений в стандартном CSS
    top: (20px / 5px);         // Производится деление (но только при использовании скобок)
    top: #{$var1} / #{$var2};  // Выводится как обычный CSS-код, деление не выполняется
    top: $var1 / $var2;        // Деление выполняется
    top: random(4) / 5;        // Деление выполняется (если использовать в паре с функцией)
    top: 2px / 4px + 3px;      // Деление выполняется, если добавлена ещё одно арифметическое действие
}
        # Директива @if 
принимает выражение SassScript и использует вложенные в неё стили в случае, если выражение возвращает любое значение, кроме false или null.

Ниже показано, как работают директивы @if и @else, вложенные в миксин.

@mixin spacing($padding, $margin) {
    @if ($padding > $margin) {
        padding: $padding;
    } @else {
        padding: $margin;
    }
}

.container {
    @include spacing(10px, 20px);
}
Сравнение в действии. Миксин spacing выберет размеры padding’а, если тот будет больше, чем margin.
.container { padding: 20px; }
Использование логических операторов Sass для создания кнопки, у которой будет меняться фон в зависимости от её ширины.

@mixin button-color ($height, $width) {
    @if (($height < $width) and ($width >= 35px)) {
        background-color: blue;    
    } @else {
        background-color: green;
    }
}

.button {
    @include button-color(20px, 30px)
}
# Строки
В CSS определено 2 типа строк: с кавычками и без. Sass распознаёт и то, и другое. В итоге вы получите в CSS тот тип строк, который использовали в Sass.

В некоторых случаях можно добавить строки в допустимые значения CSS без кавычек, но только если добавленная строка является завершающим элементом.

p {
    font: 50px Ari + "al"; // Компилируется в 50px Arial
}
# Операторы управления потоками
В SCSS есть функции (function()) и директивы (@directive). Чуть выше мы уже рассматривали пример функции, когда изучали передачу аргументов внутри миксинов.

Функции обычно заключаются в скобки, следующие сразу за её именем. А директива начинается с символа @.

Подобно JavaScript, SCSS позволяет работать со стандартным набором операторов управления потоками.

if()
if() — это функция (и иногда основа искусственного интеллекта).

Её использование выглядит довольно примитивным: оператор вернёт одно из двух обозначенных в условии значений.
/* Использование функции if() */
if (true, 1px, 2px) => 1px;
if (false, 1px, 2px) => 2px;
@if
@if — это директива, использующаяся для разветвления на основе условия.

/* Использование директивы @if */
p {
    @if 1 + 1 == 2 { border: 1px solid;  }
    @if 7 < 5      { border: 2px dotted; }
    @if null       { border: 3px double;  }
}
Ниже показано комбо-разветвление с добавлением директивы @else.
/* Создание переменной $type */
$type: river;

/* Окрашивание контейнеров в синий в случае, если значение для переменной $type — river */
div {
    @if $type == river {
        color: blue;
    }
}

/* Условные цвета для текста в теге <p> */
p {
    @if $type == tree {
        color: green;
    } @else if $type == river {
        color: blue;
    } @else if $type == dirt {
        color: brown;
    }
}

# Проверка на наличие родительского элемента
Амперсанд выбирает родительский элемент, если тот существует. В ином случае вернёт null. Поэтому может использоваться совместно с директивой @if.

В следующих примерах рассмотрим создание условных CSS-стилей в зависимости от наличия родительского элемента.

/* Проверка на наличие родительского элемента */
@mixin does-parent-exist {
    @if & {
        /* Применение голубого цвета родительскому элементу, если он существует */
        &:hover {
            color: blue;
        }
    } @else {
        /* Родительский элемент отсутствует, применение голубого цвета к ссылкам */
        a {
            color: blue;
        }
    }
}
# Директива @for
Директива @for выводит набор стилей заданное число раз. Для каждого повторения используется переменная-счётчик для изменения вывода.

Директива @for итерируется 5 раз.

@for $i from 1 through 5 {
    .definition-#{$i} { width: 10px * $i; }
}
Результат компиляции в CSS:

.definition-1 { width: 10px; }
.definition-2 { width: 20px; }
.definition-3 { width: 30px; }
.definition-4 { width: 40px; }
.definition-5 { width: 50px; }
# Директива @each
Директива @each устанавливает $var в каждое из значений списка или словаря и выводит содержащиеся в ней стили, используя соответствующее значение $var.

@each $animal in platypus, lion, sheep, dove {
    .#{$animal}-icon {
        background-image: url("/images/#{$animal}.png")
    }
}
# Директива @while
Директива @while принимает выражение SassScript и циклично выводит вложенные в неё стили, пока выражение вычисляется как true. Она может быть использована для создания более сложных циклов, чем таких, для которых подходит @for, хотя она бывает необходима довольно редко. Например:

$index: 5;
@while $index > 0 {
    .element-#{$index} { width: 10px * $index; }
    $index: $index - 1;
}
# Функции в Sass/SCSS
Используя Sass/SCSS можно использовать функции так же, как и в других языках.

Создадим функцию three-hundred-px(), возвращающую 300px.

@function three-hundred-px() {
    @return 300px;
}

.name {
    width: three-hundred-px();
    border: 1px solid gray;
    display: block;
    position: absolute;
}

Функции в Sass могут возвращать любое корректное значение CSS и могут быть назначены любому свойству. Они даже могут быть рассчитаны на основе переданного аргумента.

@function double($width) {
    @return $width * 2;
}
